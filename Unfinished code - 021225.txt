pi = 3.14159265

# Parameters need to be input to be the same as in experiment.
length = 50  # /
dx = 0.01  # m
rho = 7900  # kg/m3
cp = 470  # J/kgK
k = 10  # W/mK
h = 10  # W/m2K
d = 7.85e-3  # m
p = pi * d  # m
a = pi * (d / 2) ** 2  # m2
q = 0.75  # W
q_in = q/a  # W/m2
T_amb = 273 + 22.5  # K

simulation_time = 5000  # s
dt = 0.01  # s
num_steps = round(simulation_time/dt)
interval = 30000

# TDMA method to compute temperatures in the next time step.
def thomas(a, b, c, z):
    m = len(b)
    U = [0 for k in range(0, m)]
    L = [0 for k in range(1, m)]
    U[0] = b[0]

    for k in range(0, m - 1):
        L[k] = a[k] / U[k]
        U[k + 1] = b[k + 1] - L[k] * c[k]

    y = [el for el in z]
    for k in range(1, m):
        y[k] = z[k] - L[k - 1] * y[k - 1]

    x = [el for el in y]
    x[m - 1] = x[m - 1] / U[m - 1]
    for k in range(m - 2, -1, -1):
        x[k] = (y[k] - c[k] * x[k + 1]) / U[k]
    return x

# Prints temperatures of control volumes at time time, x is number of decimal places.
# The first outpur number is time, the others are temperatures at designated space points along the bar.
def print_temperatures(cvs, x, time):
    arr2 = [0] * (len(cvs) + 1)
    arr2[0] = round(time, x)
    for k in range(1, len(cvs) + 1):
        arr2[k] = round(cvs[k - 1], x)
        k += 1
    print(str(arr2))

# Prints the time evolution of the temperature of the chosen space point.
# This method was written on spot so the numebr in print at the bottom would need to be moved to arguments.
def print_as_exp(cvs, x, time):
    arr2 = [0] * (len(cvs) + 1)
    arr2[0] = round(time, x)
    for k in range(1, len(cvs) + 1):
        arr2[k] = round(cvs[k - 1], x)
        k += 1
    arr1 = [0, 0, 0, 0, 0, 0]
    arr1[0] = round(time, x)
    arr1[1] = round(arr2[5] - 273.0, x)
    arr1[2] = round(arr2[10] - 273.0, x)
    arr1[3] = round(arr2[15] - 273.0, x)
    arr1[4] = round(arr2[20] - 273.0, x)
    arr1[5] = round(arr2[30] - 273.0, x)

    print(arr1[1])

# Builds the system matrix - system of equations, without the right hand side.
def build_matrix():

    underdiag = [0.0] * length
    diag = [0.0] * length
    upperdiag = [0.0] * length

    # left boundary:
    underdiag[0] = 0
    diag[0] = rho * cp * dx ** 2 + k * dt + \
              h * p/a * dx ** 2 * dt
    upperdiag[0] = -k * dt

    # right boundary:
    underdiag[-1] = 
    diag[-1] = 
    upperdiag[-1] = 


    # other control volumes:
    for i in range(1, length - 1):
        underdiag[i] = 
        diag[i] = 
        upperdiag[i] = 

    return underdiag[1:], diag, upperdiag[:-1]

# builds the right-hand side of the system of equations.
def build_rhs(cvs):
    rhs = [0.0] * length
    rhs[0] = (rho * cp * dx ** 2) * cvs[0] + \
             q_in * dx * dt + h * p/a * dx ** 2 * dt * T_amb
    rhs[-1] = (rho * cp * dx ** 2) * cvs[-1] + \
              (h * p/a * dx ** 2 * dt + k * dt) * T_amb
    for i in range(1, length - 1):
        rhs[i] = rho * cp * dx ** 2 * cvs[i] + \
                 h * p / a * dx ** 2 * dt * T_amb

    return rhs


######## Simulation ###########

new_temperatures = [0] * length
cvs = [295.0] * length

time = 0.0

print_temperatures(cvs, 2, time)
underdiag, diag, upperdiag = build_matrix()
rhs = build_rhs(cvs)

for i in range(num_steps):
    rhs = build_rhs(cvs)
    new_temperatures = thomas(underdiag, diag, upperdiag, rhs)
    time += dt
    for j in range(length):
        cvs[j] = new_temperatures[j]
    if i % interval == 0:
        print_temperatures(cvs, 2, time)
        # print_as_exp(cvs, 2, time)
    # if time % 10 == 0:
    #     print_temps.print_as_exp(cvs, 2, time)